Starting code feedback for Agnieszka, Week3

Current Points = 100

Note that: 
(1) Major sections begin with a double "====" line 
(2) Subsections begin with a single "====" line 
(3) Code output or text file content are printed within single "*****" lines 

======================================================================
======================================================================
Your Git repo size this week is about 1.56 MiB on disk 

PART 1: Checking project workflow...

Found the following directories in parent directory: week2, week3, .git, week1, Feedback

Found the following files in parent directory: .gitignore, README.md

Checking for key files in parent directory...

Found .gitignore in parent directory, great! 

Printing contents of .gitignore:

**********************************************************************
*~ 
*.tmp
*.jpg
*.png
*.aux
*.bbl
*.log
*.blg
.csv
.pdf

#Python
__pycache__/
*.py[cod]
*$py.class

**********************************************************************

Found README in parent directory, named: README.md

Printing contents of README.md:

**********************************************************************
# README file for my CMEE Coursework Repository

## Brief description: 
CMEECourseWork directory contains a set of folders that are created weekly. Each folder stores weekly assignments and practice files. For more detailed description go to README files in respective weekly folders. The content of this file will be continuously updated.

## Languages: 
bash, Unix shell, Python

## Dependencies: -

## Installation: -

## Project structure and Usage: 
1) week1 folder - stores code, data & results from 1st to 7th Oct 2022.
2) week2 folder - stores code, data & results from 9th to 14th Oct 2022.
3) week3 folder - stores code, data & results from 17th to 21st Oct 2022.

## Contact: 
Agnes Szwarczynska; aas122@ic.ac.uk


**********************************************************************

======================================================================
Looking for the weekly directories...

Found 3 weekly directories: week1, week2, week3

The Week3 directory will be assessed 

======================================================================
======================================================================
PART 2: Checking weekly code and workflow...

======================================================================
Assessing WEEK3...

Found the following directories: code, sandbox, data, results

Found the following files: README.md

Checking for readme file in weekly directory...

Found README in parent directory, named: README.md

Printing contents of README.md:

**********************************************************************
# README file for week3

## Brief description: 
This folder conatins a set of scripts that were created to practise for loops, if statememnts, vectorization and data wrangling & visualisation in R.

## Languages: 
R

## Dependencies: -

## Installation: -

## Project structure and Usage: 

### week3 code folder contains following files:
1) basic_io.R - a simple script to illustrate R input-output
2) control_flow.R - practicing control flow in R
3) next.R - practicing next statement
4) break.R - practicing using next and break statements
5) boilerplate.R - a simple boilerplate
6) R_conditionals.R - checking whether a given number is an integer, prime etc.
7) TreeHeight.R - calculating tree height and saving the input as a csv file
8) Vectorize1.R - comparing loops and in-bulit vectorized function
9) preallocate.R - comparing time needed to run the function without and with pre-allocation
10) apply1.R - exploring the apply() function
11) apply2.R - exploring the apply() function using matrices
12) sample.R - generating a random population and performing operations on it
13) Ricker.R - ploting the exponential growth
14) Vectorize2.R - practical: vectorizing the stochastic Ricker model 
15) browse.R - debugging with browser() function
16) try.R - debugging with try() function
17) Florida.R - practical: plotting correlation coefficients and producing LaTeX files
18) Florida_Latex.tex - a LaTeX file
19) DataWrang.R - wrangling biological data
20) DataWrangTidy.R - practical: wrangling biological data using tidyverse package
21) PP_Dist.R - practical: plotting predator and prey mass distribution
22) CompileLaTex_Florida.sh - compiling the output of the Florida.R practical and saving it in results
23) PP_Regress.R - practical: plotting nested linear regression and producing a summary table
24) GPDD_Data.R - practical: plotting species distribution 
25) Girko.R - exploring Girko’s circular law
26) MyBars.R - using the ggplot geom text to annotate a plot
27) plotLin.R - annotating a linear regression plot 
28) SQLinR.R - exploring databases
 

data folder - contains input files

sandbox - contains practice files that can be ignored

results - contains output files

## Contact: 
Agnes Szwarczynska; aas122@ic.ac.uk
**********************************************************************

Results directory is empty - good! 

Found 28 code files: Florida_Latex.tex, Girko.R, Vectorize1.R, TreeHeight.R, apply2.R, CompileLaTex_Florida.sh, PP_Regress.R, browse.R, boilerplate.R, control_flow.R, DataWrangTidy.R, Vectorize2.R, SQLinR.R, PP_Dists.R, preallocate.R, try.R, MyBars.R, Ricker.R, break.R, apply1.R, DataWrang.R, plotLin.R, basic_io.r, GPDD_Data.R, Florida.R, next.R, sample.R, R_conditionals.R

======================================================================
Testing script/code files...

======================================================================
Inspecting script file Florida_Latex.tex...

File contents are:

**********************************************************************
\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{float}
\usepackage[left=20mm, right=20mm, top=2mm, bottom=20mm]{geometry}



\title{Is Florida getting warmer?}
\author{Agnes Szwarczynska\, aas122@ic.ac.uk} 
\date{\today}



\begin{document}
    \maketitle

    \section{Introduction}

   The aim of this practical was to investigate whether there is any correlation between the temperatures and years in the 20th century in Key West in Florida, USA.

    \section{Materials \& Methods}
    
    The true (pearson) correlation coefficient has been calculated using EcolArchives-E089-51-D1.csv data file containing set of annual temperatures in Key West in Florida, USA from the 20th century. The distribution of generated correlation coefficients has been produced by randomly re-assigning temperatures to years 10000 times. The true correlation coefficient was then plotted against the distribution - a standard p-value could not be used in this case since measurements of climatic variables across successive years are not independent from each other.
    

    \section{Results}
    
\begin{figure}[H]
\centering
\includegraphics[scale=0.2]{../data/plot1.png}
\caption{Temperatures in the 20th century in in Key West in Florida, USA }
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[scale=0.2]{../data/histogram1.png}
\caption{Distribution of randomly generated correlation coefficients. Red line depicts the true correlation coefficient from the original dataset.}
\end{figure}
    
    \section{Discussion}
    
    After calculating what fraction of the random correlation coefficients were bigger than the original one (asymptotic p-value was smaller than 0.001) and visually assessing the histogram, we can conclude that temperatures in the past century have been continuously increasing in Florida. 

\end{document}
**********************************************************************

Testing Florida_Latex.tex...

======================================================================
Inspecting script file Girko.R...

File contents are:

**********************************************************************
#!usr/bin/env Rscript

###Cleaning the environment
rm(list = ls())

###Libraries
library(ggplot2)

###Building a function object that will calculate the ellipse


build_ellipse <- function(hradius, vradius){ # function that returns an ellipse
  npoints = 250
  a <- seq(0, 2 * pi, length = npoints + 1)
  x <- hradius * cos(a)
  y <- vradius * sin(a)  
  return(data.frame(x = x, y = y))
}

N <- 250 # Assign size of the matrix

M <- matrix(rnorm(N * N), N, N) # Build the matrix

eigvals <- eigen(M)$values # Find the eigenvalues

eigDF <- data.frame("Real" = Re(eigvals), "Imaginary" = Im(eigvals)) # Build a dataframe

my_radius <- sqrt(N) # The radius of the circle is sqrt(N)

ellDF <- build_ellipse(my_radius, my_radius) # Dataframe to plot the ellipse

names(ellDF) <- c("Real", "Imaginary") # rename the columns

###Plotting
# plot the eigenvalues
p <- ggplot(eigDF, aes(x = Real, y = Imaginary))
p <- p +
  geom_point(shape = I(3)) +
  theme(legend.position = "none")

# now add the vertical and horizontal line
p <- p + geom_hline(aes(yintercept = 0))
p <- p + geom_vline(aes(xintercept = 0))

# finally, add the ellipse
p <- p + geom_polygon(data = ellDF, aes(x = Real, y = Imaginary, alpha = 1/20, fill = "red"))
p

###Saving the file in results
pdf("../results/Girko.pdf")
print(p)
dev.off()
**********************************************************************

Testing Girko.R...

Output (only first 500 characters): 


**********************************************************************
pdf 
  2 

**********************************************************************

Code ran without errors

Time consumed = 2.63491s

======================================================================
Inspecting script file Vectorize1.R...

File contents are:

**********************************************************************
#!usr/bin/env Rscript

###Practicing vectorization

M <- matrix(runif(1000000),1000,1000)  ###initialising a matrix

SumAllElements <- function(M) {
  Dimensions <- dim(M)
  Tot <- 0
  for (i in 1:Dimensions[1]) {
    for (j in 1:Dimensions[2]) {
      Tot <- Tot + M[i,j]
    }
  }
  return (Tot)
}
 
print("Using loops, the time taken is:") ###comparing times for loops and vectorised function
print(system.time(SumAllElements(M)))

print("Using the in-built vectorized function, the time taken is:")
print(system.time(sum(M)))
**********************************************************************

Testing Vectorize1.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Using loops, the time taken is:"
   user  system elapsed 
  0.164   0.000   0.164 
[1] "Using the in-built vectorized function, the time taken is:"
   user  system elapsed 
  0.001   0.000   0.001 

**********************************************************************

Code ran without errors

Time consumed = 0.69824s

======================================================================
Inspecting script file TreeHeight.R...

File contents are:

**********************************************************************
#!usr/bin/env Rscript

# This function calculates heights of trees given distance of each tree 
# from its base and angle to its top, using  the trigonometric formula 
#
# height = distance * tan(radians)
#
# ARGUMENTS
# degrees:   The angle of elevation of tree
# distance:  The distance from base of tree (e.g., meters)
#
# OUTPUT
# The heights of the tree, same units as "distance"

List_of_trees <- read.csv("../data/trees.csv", header = TRUE)
List_of_trees <- as.data.frame(List_of_trees)

List_of_trees <- List_of_trees[,-1]

TreeHeight <- function(degrees, distance) {
    radians <- degrees * pi/180
    height <- distance * tan(radians)
    return (height)
}


x <- rep(NA,120)
for (i in rownames(List_of_trees)) {
    distance <- List_of_trees[i, "Distance.m"]
    degrees  <- List_of_trees[i, "Angle.degrees"]
    
    Tree.Height.value <- (TreeHeight(degrees, distance))
    
    x[as.integer(i)] <- Tree.Height.value
    print(Tree.Height.value)
    
}

print(x)

List_of_trees['Tree.Height.m'] <- x


write.csv(List_of_trees, "../results/Trees_output.csv")

**********************************************************************

Testing TreeHeight.R...

Output (only first 500 characters): 


**********************************************************************
[1] 27.80212
[1] 45.24603
[1] 14.66548
[1] 14.93418
[1] 35.97036
[1] 32.41021
[1] 17.45824
[1] 30.13738
[1] 20.31248
[1] 24.43166
[1] 27.50213
[1] 25.1559
[1] 29.39248
[1] 28.18639
[1] 30.73989
[1] 39.73756
[1] 24.69074
[1] 17.75982
[1] 20.81735
[1] 35.04535
[1] 31.85708
[1] 31.9386
[1] 13.48215
[1] 33.32665
[1] 30.2327
[1] 35.95132
[1] 21.94397
[1] 40.90508
[1] 20.74785
[1] 34.99243
[1] 25.92783
[1] 28.39448
[1] 33.66718
[1] 20.8697
[1] 22.86062
[1] 28.73253
[1] 17.74079
[1] 28.6979
[1] 34.99812
**********************************************************************

Code ran without errors

Time consumed = 0.57354s

======================================================================
Inspecting script file apply2.R...

File contents are:

**********************************************************************
#!usr/bin/env Rscript

SomeOperation <- function(v) { # (What does this function do?)
if (sum(v) > 0) { #note that sum(v) is a single (scalar) value #if the sum of values in a row > 0 then multiply by 100
    return (v *100)
} else {
    return (v)
}

}

M <- matrix(rnorm(100), 10, 10)  # using apply()
print (apply(M, 1, SomeOperation))

#print(M) #comparing matrices
    
**********************************************************************

Testing apply2.R...

Output (only first 500 characters): 


**********************************************************************
             [,1]        [,2]        [,3]       [,4]        [,5]       [,6]
 [1,]  0.74020144  -10.526043 -0.57285709 -84.528207  0.32605336 182.357231
 [2,]  0.06800495  -66.710826 -0.09256645  65.810090 -0.88191993   2.396001
 [3,]  1.60855046   58.506992 -0.96782374  60.736368  1.15130314 -18.129249
 [4,] -0.87523652  -18.244825  0.59132629  52.036285 -0.11853335 -25.870564
 [5,] -0.18819306    4.999750 -1.17605796  89.697436 -0.05809888  77.631929
 [6,] -0.98432400  -19.165273  0.71850844 -14
**********************************************************************

Code ran without errors

Time consumed = 0.51448s

======================================================================
Inspecting script file CompileLaTex_Florida.sh...

File contents are:

**********************************************************************
#!/bin/bash

if [ $# -eq 0 ]   #Checking whether the user provided an argument
    then 
        echo "Please provide a file argument"
    exit
fi

if [[ $1 == *.tex ]]  ##Checking whether the input file contains .tex extension. If not, then it adds the .tex extension.
then
    pdflatex $1
    bibtex $(basename "$1" .tex)
    pdflatex $1
    pdflatex $1
    mv $(basename "$1" .tex).pdf ../results
    evince ../results/$(basename "$1" .tex).pdf &
else
    pdflatex $1.tex
    bibtex $1
    pdflatex $1.tex
    pdflatex $1.tex
    mv $1.pdf ../results
    evince ../results/$1.pdf & 
fi


## Cleanup
rm *.aux
rm *.log
rm *.bbl
rm *.blg

exit
**********************************************************************

Testing CompileLaTex_Florida.sh...

Output (only first 500 characters): 


**********************************************************************
Please provide a file argument

**********************************************************************

Code ran without errors

Time consumed = 0.00689s

======================================================================
Inspecting script file PP_Regress.R...

File contents are:

**********************************************************************
#!usr/bin/env Rscript

library(ggplot2)
library(dplyr)
library(broom)
library(tibble)
library(tidyr)
library(purrr)
library(plyr)

# load the data
predators <- as.data.frame(read.csv("../data/EcolArchives-E089-51-D1.csv"))


#plot the data
p <- qplot(Prey.mass, Predator.mass, log = "xy", xlab = "log[Prey mass (grams)]",
      ylab = "log[Predator mass (grams)]", facets = Type.of.feeding.interaction ~., data = predators,
      colour = Predator.lifestage) + geom_smooth(method = "lm",fullrange = TRUE)
final_plot <- p + theme_bw()+
  theme(legend.position = "bottom")+
  geom_point(shape=1,aes(colour = Predator.lifestage)) 

final_plot

#saving the pdf output in the results folder

pdf("../results/PP_Regress_plots.pdf")
print(final_plot)
dev.off()

#making units uniform - changing mg to g
newpreymass <- c()
for (i in 1:nrow(predators)){
  p <- predators[i,]
  if (p$Prey.mass.unit=="mg"){
    newpreymass <- c(newpreymass, p$Prey.mass/1000)
  }
  else {
    newpreymass <- c(newpreymass, p$Prey.mass)
  }
    
}

predators$Prey.mass <- newpreymass
predators$Prey.mass.unit <- rep("g",34931)

#performing linear regression

fit_model <- function(x) {lm(log(Predator.mass) ~ log(Prey.mass), data = x)}
models <- dlply(predators, .(Type.of.feeding.interaction, Predator.lifestage), fit_model)


#summary_df <- data.frame(Type.of.feeding.interaction=character(),
#                         Predator.lifestage=character(),
#                         Regression.slope=double(),
#                         Regression.intercept=double(),
#                         R.squared=double(),
#                         F.statistic=double(),
#                         P.value=double()
#                         )

#creating an empty data frame
df <- data.frame()

#extracting pieces of information:intercept, R^2, f.value, slope & p-value and adding them to the data frame
for (model in models){
  # print(as.numeric(summary(model)$fstatistic[1]))
  summary_table <- summary(model)
  values_for_df <- c(summary_table$coefficients[1], #intercept
                     summary_table$r.squared, #r.squared
                     as.numeric(summary_table$fstatistic[1]), #f.value
                     #summary(model)$fstatistic[1],
                     summary_table$coefficients[2], #slope
                     summary_table$coefficients[1,4]) #p-value
  df = rbind(df, values_for_df)
}

#Giving meaningful column names

colnames(df)[1] <- "Intercept"
colnames(df)[2] <- "R.squared"
colnames(df)[3] <- "F.value"
colnames(df)[4] <- "Slope"
colnames(df)[5] <- "P.value"

#Creating first two rows with the Predator.lifestage & Type.of.feeding.interaction data 
Predator.lifestage <- c("larva/juvenile","adult","juvenile","larva/juvenile","postlarva","postlarva","adult","juvenile","larva", "larva/juvenile", "postlarva", "adut", "juvenile","larva","larva/juvenile","postlarva", "postlarva/juvenile", "adult")

df <- cbind(Predator.lifestage, df)

Type.of.feeding.interaction <-c("insectivorous", c(rep('piscivorous',5)),c(rep('planktivorous', 5)), c(rep("predacious", 6)), "predacious/piscivorous")

df <- cbind(Type.of.feeding.interaction, df)

#Saving the output as a csv file
write.csv(df, "../results/PP_Regress_Results.csv", row.names = FALSE)


**********************************************************************

Testing PP_Regress.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***


Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

------------------------------------------------------------------------------
You have loaded plyr after dplyr - this is likely to cause problems.
If you need functions from both plyr and dplyr, please load plyr first, then dplyr:
library(plyr); library(dplyr)
------------------------------------------------------------------------------

Attaching package: ‘plyr’

The following object is masked from ‘package:purrr’:

    compact

The following objects are masked from ‘package:dplyr’:

    arrange, count, desc, failwith, id, mutate, rename, summarise,
    summarize

`geom_smooth()` using formula 'y ~ x'
Warning messages:
1: In qt((1 - level)/2, df) : NaNs produced
2: In max(ids, na.rm = TRUE) :
  no non-missing arguments to max; returning -Inf
`geom_smooth()` using formula 'y ~ x'
Warning messages:
1: In qt((1 - level)/2, df) : NaNs produced
2: In max(ids, na.rm = TRUE) :
  no non-missing arguments to max; returning -Inf

======================================================================
Inspecting script file browse.R...

File contents are:

**********************************************************************
#!usr/bin/env Rscript

Exponential <- function(N0 = 1, r = 1, generations = 10) {
  # Runs a simulation of exponential growth
  # Returns a vector of length generations
  
  N <- rep(NA, generations)    # Creates a vector of NA
  
  N[1] <- N0
  for (t in 2:generations) {
    N[t] <- N[t-1] * exp(r)
    browser()
  }
  return (N)
}

plot(Exponential(), type="l", main="Exponential growth")

**********************************************************************

Testing browse.R...

Output (only first 500 characters): 


**********************************************************************
Called from: Exponential()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()

**********************************************************************

Code ran without errors

Time consumed = 0.55128s

======================================================================
Inspecting script file boilerplate.R...

File contents are:

**********************************************************************
#!usr/bin/env Rscript
# A boilerplate R script

MyFunction <- function(Arg1, Arg2) {
  
  # Statements involving Arg1, Arg2:
  print(paste("Argument", as.character(Arg1), "is a", class(Arg1))) # print Arg1's type
  print(paste("Argument", as.character(Arg2), "is a", class(Arg2))) # print Arg2's type
    
  return (c(Arg1, Arg2)) #this is optional, but very useful
}

MyFunction(1,2) #test the function
MyFunction("Riki","Tiki") #A different test
**********************************************************************

Testing boilerplate.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Argument 1 is a numeric"
[1] "Argument 2 is a numeric"
[1] 1 2
[1] "Argument Riki is a character"
[1] "Argument Tiki is a character"
[1] "Riki" "Tiki"

**********************************************************************

Code ran without errors

Time consumed = 0.44810s

======================================================================
Inspecting script file control_flow.R...

File contents are:

**********************************************************************
#!usr/bin/env Rscript

###Control flow in R

a <- TRUE
if (a == TRUE) {
    print("a is TRUE")
} else {
    print ("a is FALSE")
}

a

a <- TRUE
if (a) {
    print("a is TRUE")
} else {
    print ("a is FALSE")
}

a

# if statements

z <- runif(1)
if (z <= 0.5) {print ("Less than a half")}
z

z <- runif(1)
if (z <= 05) {
    print ("Less than a half")
}

# for loops
for (i in 1:10) {
    j <- i * i
    print(paste(i,"square is", j))
}

### Running a loop over a vector of strings

for(species in c("Helidoxa rubinoides",
                "Boissonneaua jardini",
                "Sula nebouxii")) {
    print(paste("The species is", species))
                }
                
v1 <- c("a","bc","def")
for (i in v1) {
    print(i)
}

i <- 0
while (i < 10) {
    i <- i+1
    print(i^2)
}

i
**********************************************************************

Testing control_flow.R...

Output (only first 500 characters): 


**********************************************************************
[1] "a is TRUE"
[1] TRUE
[1] "a is TRUE"
[1] TRUE
[1] "Less than a half"
[1] 0.0105735
[1] "Less than a half"
[1] "1 square is 1"
[1] "2 square is 4"
[1] "3 square is 9"
[1] "4 square is 16"
[1] "5 square is 25"
[1] "6 square is 36"
[1] "7 square is 49"
[1] "8 square is 64"
[1] "9 square is 81"
[1] "10 square is 100"
[1] "The species is Helidoxa rubinoides"
[1] "The species is Boissonneaua jardini"
[1] "The species is Sula nebouxii"
[1] "a"
[1] "bc"
[1] "def"
[1] 1
[1] 4
[1] 9
[1] 16
[1] 25
[1] 3
**********************************************************************

Code ran without errors

Time consumed = 0.39303s

======================================================================
Inspecting script file DataWrangTidy.R...

File contents are:

**********************************************************************
#!usr/bin/env Rscript

################################################################
################## Wrangling the Pound Hill Dataset ############
################################################################

####Libraries
library(tidyverse)

############# Load the dataset ###############
# header = false because the raw data don't have real headers
MyData <- as.matrix(read.csv("../data/PoundHillData.csv", header = FALSE))

# header = true because we do have metadata headers
MyMetaData <- read.csv("../data/PoundHillMetaData.csv", header = TRUE, sep = ";")

#####creating a df
MyData2 <- as.data.frame(MyData)
class(MyData2)


############# Replace species absences with zeros ###############
MyData2[MyData2 == ""] = NA
MyData2

MyData2 <- MyData2 %>% replace(is.na(.), 0) #replace() function from tidyverse
MyData2

#####creating a tibble

MyData_t <- dplyr::as_tibble(MyData2) 
class(MyData_t)

############# Inspect the dataset ###############
head(MyData)
dim(MyData)
dplyr::glimpse(MyData) #### same as str()
utils::View(MyData) #same as fix()
utils::View(MyMetaData)

############# Transpose ###############
# To get those species into columns and treatments into rows 

MyData_t <- as_tibble(cbind(nms = names(MyData_t), t(MyData_t)))
MyData_t

head(MyData_t)
dim(MyData_t)


############# Convert raw matrix to data frame ###############

TempData <- as.data.frame(MyData_t[-1,],stringsAsFactors = F) #stringsAsFactors = F is important!
colnames(TempData) <- MyData_t[1,] # assign column names from original data

######removing the redundant first column
TempData <- TempData[,-1]
############# Convert from wide to long format  ###############
MyWrangledData <- TempData %>% 
  gather(key = Species, value = Count, -Cultivation, -Block, -Plot, -Quadrat)

MyWrangledData[, "Cultivation"] <- as.factor(MyWrangledData[, "Cultivation"])
MyWrangledData[, "Block"] <- as.factor(MyWrangledData[, "Block"])
MyWrangledData[, "Plot"] <- as.factor(MyWrangledData[, "Plot"])
MyWrangledData[, "Quadrat"] <- as.factor(MyWrangledData[, "Quadrat"])
MyWrangledData[, "Count"] <- as.integer(MyWrangledData[, "Count"])

str(MyWrangledData)
head(MyWrangledData)
dim(MyWrangledData)

############# Exploring the data (extend the script below)  ###############
**********************************************************************

Testing DataWrangTidy.R...

Output (only first 500 characters): 


**********************************************************************
[1] "data.frame"
                           V1      V2      V3      V4      V5      V6   V7   V8
1                 Cultivation october october october october october  may  may
2                       Block       a       a       a       a       a    a    a
3                        Plot       1       1       1       1       1    2    2
4                     Quadrat      Q1      Q2      Q3      Q4      Q5   Q1   Q2
5        Achillea millefolium       4       8       3      20       6    4 <NA>
6   
**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

── Attaching packages ─────────────────────────────────────── tidyverse 1.3.1 ──
✔ ggplot2 3.3.5     ✔ purrr   0.3.5
✔ tibble  3.1.8     ✔ dplyr   1.0.8
✔ tidyr   1.2.0     ✔ stringr 1.4.1
✔ readr   2.1.2     ✔ forcats 0.5.1
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
Warning message:
The `x` argument of `as_tibble.matrix()` must have unique column names if `.name_repair` is omitted as of tibble 2.0.0.
Using compatibility `.name_repair`. 

======================================================================
Inspecting script file Vectorize2.R...

File contents are:

**********************************************************************
#!usr/bin/env Rscript

# Runs the stochastic Ricker equation with gaussian fluctuations

rm(list = ls())

stochrick <- function(p0 = runif(1000, .5, 1.5), r = 1.2, K = 1, 
                      sigma = 0.2,numyears = 100){


  N <- matrix(NA, numyears, length(p0))  #initialize empty matrix

  N[1, ] <- p0

  for (pop in 1:length(p0)) { #loop through the populations

    for (yr in 2:numyears){ #for each pop, loop through the years

      N[yr, pop] <- N[yr-1, pop] * exp(r * (1 - N[yr - 1, pop] / K) + rnorm(1, 0, sigma)) # add one fluctuation from normal distribution
    
     }
  
  }
 return(N)

}


stochrickvect <- function(p0 = runif(1000, .5, 1.5), r = 1.2, K = 1, sigma = 0.2,numyears = 100){
  
  
  N_2 <- matrix(NA, numyears, length(p0))  #initialize empty matrix

  N_2[1, ] <- p0

for (yr in 2:numyears) { #loop through the years
  
    N_2[yr, ] <- N_2[yr-1, ] * exp(r * (1 - N_2[yr - 1, ] / K) + rnorm(length(p0), 0, sigma)) # add one fluctuation from normal distribution
    
  }
  

return(N_2)

}


# Now write another function called stochrickvect that vectorizes the above to
# the extent possible, with improved performance: 

print("Vectorized Stochastic Ricker takes:")
print(system.time(res2<-stochrickvect()))

print("Non-vectorized Stochastic Ricker takes:")
print(system.time(res1<-stochrick()))
**********************************************************************

Testing Vectorize2.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Vectorized Stochastic Ricker takes:"
   user  system elapsed 
  0.075   0.000   0.076 
[1] "Non-vectorized Stochastic Ricker takes:"
   user  system elapsed 
  0.492   0.036   0.528 

**********************************************************************

Code ran without errors

Time consumed = 1.07308s

======================================================================
Inspecting script file SQLinR.R...

File contents are:

**********************************************************************
#install the sqlite package
#install.packages('sqldf')

# To load the packages
library(sqldf)

# The command below opens a connection to the database.
#If the database does not yet exist, one is created in the working directory of R.
db <- dbConnect(SQLite(), dbname='../results/Test.sqlite')

# Now let's enter some data to the table
# Using the db connection to our database, the data are entered using SQL queries
# The next command just create the table
dbSendQuery(conn = db,
            "CREATE TABLE Consumer
       (OriginalID TEXT,
        ConKingdom TEXT,
        ConPhylum TEXT,
        ConSpecies TEXT)")

# Once the table is created, we can enter the data.
#INSERT specifies where the data is entered (here the School table).
#VALUES contains the data

 dbSendQuery(conn = db,
         "INSERT INTO Consumer
         VALUES (1, 'Animalia', 'Arthropoda', 'Chaoborus trivittatus')")
 dbSendQuery(conn = db,
         "INSERT INTO Consumer
         VALUES (2, 'Animalia', 'Arthropoda', 'Chaoborus americanus')")
 dbSendQuery(conn = db,
         "INSERT INTO Consumer
         VALUES (3, 'Animalia', 'Chordata', 'Stizostedion vitreum')")


# Once we have our table, we can query the results using:

dbGetQuery(db, "SELECT * FROM Consumer")
dbGetQuery(db, "SELECT * FROM Consumer WHERE ConPhylum='Chordata'")


# Tables can be also imported from csv files.
# As example, let's use the Biotraits dataset.
# The easiest way is to read the csv files into R as data frames.
# Then the data frames are imported into the database.

Resource <- read.csv("../data/Resource.csv")  # Read csv files into R

# Import data frames into database
 dbWriteTable(conn = db, name = "Resource", value = Resource, row.names = FALSE)

# Check that the data have been correctly imported into the School table.
 dbListTables(db)                 # The tables in the database
 dbListFields(db,"Resource")       # The columns in a table
 dbReadTable(db, "Resource")    # The data in a table

# Before leaving RSQLite, there is a bit of tidying-up to do.
# The connection to the database is closed, and as precaution
# the three data frames are removed from R’s environment.
 dbDisconnect(db)            # Close connection
 rm(list = c("Resource"))   # Remove data frames



**********************************************************************

Testing SQLinR.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

Error in library(sqldf) : there is no package called ‘sqldf’
Execution halted

======================================================================
Inspecting script file PP_Dists.R...

File contents are:

**********************************************************************
###Clearing the workspace
rm(list = ls())

###Loading libraries
library(ggplot2)
library(ggpubr)
library(dplyr)


###Loading the data
predators <- as.data.frame(read.csv("../data/EcolArchives-E089-51-D1.csv"))

###Making units uniform - changing mg to g
newpreymass <- c()
for (i in 1:nrow(predators)){
  p <- predators[i,]
  if (p$Prey.mass.unit=="mg"){
    newpreymass <- c(newpreymass, p$Prey.mass/1000)
  }
  else {
    newpreymass <- c(newpreymass, p$Prey.mass)
  }
  
}

predators$Prey.mass <- newpreymass
predators$Prey.mass.unit <- rep("g",34931)


###Assigning feeding types and life stages to vectors

feeding_types <-unique(predators$Type.of.feeding.interaction)
life_stages <-unique(predators$Predator.lifestage)

###predators subplots in a pdf format
pdf("../results/Pred_Subplots.pdf")
par(mfrow = c(3, 2))


for (types in feeding_types) {
  temp_df <- subset(predators, Type.of.feeding.interaction == types)
    plot(density(log(temp_df$Predator.mass)), main = "", col = "dark red", 
         xlab = "log[Predator mass (g)] ",
         xlim = c(-10, 15),
         ylim = c(0.0, 0.4))
  }
  dev.off()

  
###prey subplots in a pdf format  
pdf("../results/Prey_Subplots.pdf")
par(mfrow = c(3, 2)) 

for (types in feeding_types) {
  temp_df <- subset(predators, Type.of.feeding.interaction == types)
  plot(density(log(temp_df$Prey.mass)), main = "", col = "dark red", 
       xlab = "log[Prey mass (g)] ",
       xlim = c(-20, 10),
       ylim = c(0.0, 0.5))
}
dev.off()

###prey mass/predator mass subplots in a pdf format 
pdf("../results/SizeRatio_Subplots.pdf")
par(mfrow = c(3, 2)) 

for (types in feeding_types) {
  temp_df <- subset(predators, Type.of.feeding.interaction == types)
  temp_var <- log(temp_df$Prey.mass)/log(temp_df$Prey.mass)
  plot(density(temp_var), main = "", col = "dark red", 
       xlab = "log(Size ratio) ",
       xlim = c(-1, 3),
       ylim = c(0.0, 4))
}
dev.off()


###First approach - producing a csv output file (didn't work well)

#for (types in feeding_types) {
#  temp_df <- subset(predators, Type.of.feeding.interaction == types)
#  temp_df$Predator.mass <- log(temp_df$Predator.mass)
#  temp_df$Prey.mass <- log(temp_df$Prey.mass)
#  new_summary <- summary(temp_df)
#  new_summary <- as.matrix(new_summary)
#  values_for_output_df <- c(new_summary[15]) #indexing is not very intuitive in this case
#  print(values_for_output_df) #checking whether the loop prints out expected value
#}


###Creating an output data frame
output_df <- predators %>%
  group_by(Type.of.feeding.interaction) %>%
  summarise(mean(log(Predator.mass)),
            median(log(Predator.mass)),
            mean(log(Prey.mass)),
            median(log(Prey.mass)),
            mean(log(Prey.mass/Predator.mass)),
            median(log(Prey.mass/Predator.mass)))

print(output_df)
###Assigning new column names
colnames(output_df) <- c("Feeding type","Predator.mean","Predator.median","Prey.mean","Prey.median","Size.ratio.mean","Size.ratio.median")



###Producing a csv file
write.csv(output_df, "../results/PP_Results.csv")

**********************************************************************

Testing PP_Dists.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

Error in library(ggpubr) : there is no package called ‘ggpubr’
Execution halted

======================================================================
Inspecting script file preallocate.R...

File contents are:

**********************************************************************
#!usr/bin/env Rscript

###Practicing pre-allocation

NoPreallocFun <- function(x) {
    a <- vector() #empty vector
    for (i in 1:x) {
        a <- c(a,i)
        #print(a)
        #print(object.size(a))
    }
}

system.time(NoPreallocFun(1000)) #displaying time needed to run the function without the pre-allocation

PreallocFun <- function(x) {
    a <- rep(NA, x)
    for (i in 1:x) {
        a[i] <- i #assign
        #print(a)
        #print(object.size(a))
    }
}

system.time(PreallocFun(1000)) #displaying time needed to run the function with the pre-allocation
**********************************************************************

Testing preallocate.R...

Output (only first 500 characters): 


**********************************************************************
   user  system elapsed 
  0.037   0.001   0.038 
   user  system elapsed 
  0.007   0.000   0.007 

**********************************************************************

Code ran without errors

Time consumed = 0.44729s

======================================================================
Inspecting script file try.R...

File contents are:

**********************************************************************
#!usr/bin/env Rscript

rm(list=ls())  ###Clearing the environment

doit <- function(x) {
    temp_x <- sample(x, replace = TRUE)
    if(length(unique(temp_x)) > 30) {#only take mean if sample was sufficient
         print(paste("Mean of this sample was:", as.character(mean(temp_x))))
        } 
    else {
        stop("Couldn't calculate mean: too few unique values!")
        }
    }


###Generating a population 

set.seed(1345) # again, to get the same result for illustration
popn <- rnorm(50)
hist(popn)

### lapply() without try()
#lapply(1:15, function(i) doit(popn))

### lapply() with try()
result <- lapply(1:15, function(i) try(doit(popn), FALSE))

###Looking at errors
class(result)

result

###Storing errors
result <- vector("list", 15) #Preallocate/Initialize
for(i in 1:15) {
    result[[i]] <- try(doit(popn), FALSE)
    }
**********************************************************************

Testing try.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Mean of this sample was: -0.11620822588674"
[1] "Mean of this sample was: -0.0468516755995931"
[1] "Mean of this sample was: -0.0890228211466614"
[1] "Mean of this sample was: -0.124229742255296"
[1] "Mean of this sample was: 0.0314144452816157"
[1] "Mean of this sample was: -0.233476945796405"
[1] "Mean of this sample was: -0.196681538928001"
[1] "Mean of this sample was: 0.0146969612111605"
[1] "Mean of this sample was: -0.234913159471725"
[1] "Mean of this sample was: -0.0497464588165691"
**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

Error in doit(popn) : Couldn't calculate mean: too few unique values!
Error in doit(popn) : Couldn't calculate mean: too few unique values!
Error in doit(popn) : Couldn't calculate mean: too few unique values!
Error in doit(popn) : Couldn't calculate mean: too few unique values!
Error in doit(popn) : Couldn't calculate mean: too few unique values!

======================================================================
Inspecting script file MyBars.R...

File contents are:

**********************************************************************
#!usr/bin/env Rscript

###Libraries
library(ggplot2)

#Cleaning the environment
rm(list = ls())

###Using the ggplot geom text to annotate a plot.

a <- read.table("../data/Results.txt", header = TRUE)
head(a)

a$ymin <- rep(0, dim(a)[1]) # append a column of zeros

# Print the first linerange
p <- ggplot(a)
p <- p + geom_linerange(data = a, aes(
  x = x,
  ymin = ymin,
  ymax = y1,
  size = (0.5)
),
colour = "#E69F00",
alpha = 1/2, show.legend = FALSE)

# Print the second linerange
p <- p + geom_linerange(data = a, aes(
  x = x,
  ymin = ymin,
  ymax = y2,
  size = (0.5)
),
colour = "#56B4E9",
alpha = 1/2, show.legend = FALSE)

# Print the third linerange:
p <- p + geom_linerange(data = a, aes(
  x = x,
  ymin = ymin,
  ymax = y3,
  size = (0.5)
),
colour = "#D55E00",
alpha = 1/2, show.legend = FALSE)

# Annotate the plot with labels:
p <- p + geom_text(data = a, aes(x = x, y = -500, label = Label))

# now set the axis labels, remove the legend, and prepare for bw printing
p <- p + scale_x_continuous("My x axis",
                            breaks = seq(3, 5, by = 0.05)) + 
  scale_y_continuous("My y axis") + 
  theme_bw() + 
  theme(legend.position = "none") 
p

###Saving the file in results
pdf("../results/MyBars.pdf")
print(p)
dev.off()
**********************************************************************

Testing MyBars.R...

Output (only first 500 characters): 


**********************************************************************
         x   y1   y2 y3 Label
1 3.515424 4320 4320  0  <NA>
2 3.533984 2160 2160  0  <NA>
3 3.557647 4320 4320  0  <NA>
4 3.569953 4320 4320  0  <NA>
5 3.578984 8640 8640  0  <NA>
6 3.585665 2160 2160  0  <NA>
pdf 
  2 

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

Warning message:
Removed 91 rows containing missing values (geom_text). 
Warning message:
Removed 91 rows containing missing values (geom_text). 

======================================================================
Inspecting script file Ricker.R...

File contents are:

**********************************************************************
#!usr/bin/env Rscript

Ricker <- function(N0=1, r=1, K=10, generations=50)
{
  # Runs a simulation of the Ricker model
  # Returns a vector of length generations
  
  N <- rep(NA, generations)    # Creates a vector of NA
  
  N[1] <- N0
  for (t in 2:generations)
  {
    N[t] <- N[t-1] * exp(r*(1.0-(N[t-1]/K)))
  }
  return (N)
}

plot(Ricker(generations=10), type="l") #Ploting the exponential growth
**********************************************************************

Testing Ricker.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.59431s

======================================================================
Inspecting script file break.R...

File contents are:

**********************************************************************
#!usr/bin/env Rscript

### Using next and break statements

i <- 0 #Initialize i
    while (i < Inf) {
        if (i == 10){
            break
        } else { #Break out of the while loop!
            cat("i equals ", i , " \n")
            i <- i + 1  #Update i
    }
}
**********************************************************************

Testing break.R...

Output (only first 500 characters): 


**********************************************************************
i equals  0  
i equals  1  
i equals  2  
i equals  3  
i equals  4  
i equals  5  
i equals  6  
i equals  7  
i equals  8  
i equals  9  

**********************************************************************

Code ran without errors

Time consumed = 0.42773s

======================================================================
Inspecting script file apply1.R...

File contents are:

**********************************************************************
#!usr/bin/env Rscript

###Practising using the apply() function

##Build a random matrix
M <- matrix(rnorm(100), 10, 10)

##Take the mean of each row
RowMeans <- apply(M, 1, mean)
print(RowMeans)

## Now the variance
RowVars <- apply(M, 1, var)
print (RowVars)

##By column
ColMeans <- apply(M, 2, mean)
print(ColMeans)
**********************************************************************

Testing apply1.R...

Output (only first 500 characters): 


**********************************************************************
 [1]  0.2006857  0.2061659 -0.2158995  0.5334265  0.5904922 -0.3332915
 [7]  0.3313026  0.1797398 -0.1748683 -0.1456516
 [1] 0.5465435 1.5597768 0.7463712 1.7627646 0.4727875 0.7301045 0.7046635
 [8] 0.5150444 0.6940102 0.7236262
 [1]  0.30192094  0.37346008  0.28676489  0.01987052  0.22836868  0.94766407
 [7] -0.30054542 -0.19516701 -0.11180710 -0.37842777

**********************************************************************

Code ran without errors

Time consumed = 0.42702s

======================================================================
Inspecting script file DataWrang.R...

File contents are:

**********************************************************************
#!usr/bin/env Rscript

################################################################
################## Wrangling the Pound Hill Dataset ############
################################################################

############# Load the dataset ###############
# header = false because the raw data don't have real headers
MyData <- as.matrix(read.csv("../data/PoundHillData.csv", header = FALSE))

# header = true because we do have metadata headers
MyMetaData <- read.csv("../data/PoundHillMetaData.csv", header = TRUE, sep = ";")

############# Inspect the dataset ###############
head(MyData)
dim(MyData)
str(MyData)
fix(MyData) #you can also do this
fix(MyMetaData)

############# Transpose ###############
# To get those species into columns and treatments into rows 
MyData <- t(MyData) 
head(MyData)
dim(MyData)

############# Replace species absences with zeros ###############
MyData[MyData == ""] = 0

############# Convert raw matrix to data frame ###############

TempData <- as.data.frame(MyData[-1,],stringsAsFactors = F) #stringsAsFactors = F is important!
colnames(TempData) <- MyData[1,] # assign column names from original data

############# Convert from wide to long format  ###############
require(reshape2) # load the reshape2 package

?melt #check out the melt function

MyWrangledData <- melt(TempData, id=c("Cultivation", "Block", "Plot", "Quadrat"), variable.name = "Species", value.name = "Count")

MyWrangledData[, "Cultivation"] <- as.factor(MyWrangledData[, "Cultivation"])
MyWrangledData[, "Block"] <- as.factor(MyWrangledData[, "Block"])
MyWrangledData[, "Plot"] <- as.factor(MyWrangledData[, "Plot"])
MyWrangledData[, "Quadrat"] <- as.factor(MyWrangledData[, "Quadrat"])
MyWrangledData[, "Count"] <- as.integer(MyWrangledData[, "Count"])

str(MyWrangledData)
head(MyWrangledData)
dim(MyWrangledData)

############# Exploring the data (extend the script below)  ###############

**********************************************************************

Testing DataWrang.R...

Output (only first 500 characters): 


**********************************************************************
     V1                     V2        V3        V4        V5        V6       
[1,] "Cultivation"          "october" "october" "october" "october" "october"
[2,] "Block"                "a"       "a"       "a"       "a"       "a"      
[3,] "Plot"                 "1"       "1"       "1"       "1"       "1"      
[4,] "Quadrat"              "Q1"      "Q2"      "Q3"      "Q4"      "Q5"     
[5,] "Achillea millefolium" "4"       "8"       "3"       "20"      "6"      
[6,] "Agrostis gigantea"    ""   
**********************************************************************

Code ran without errors

Time consumed = 10.00967s

======================================================================
Inspecting script file plotLin.R...

File contents are:

**********************************************************************
#!usr/bin/env Rscript

###Cleaning the environment
rm(list = ls())

###Libraries
library(ggplot2)

###Mathematical annotation of an axis as well as within the plot area

x <- seq(0, 100, by = 0.1)
y <- -4. + 0.25 * x +
  rnorm(length(x), mean = 0., sd = 2.5)

# and put them in a dataframe
my_data <- data.frame(x = x, y = y)

# perform a linear regression
my_lm <- summary(lm(y ~ x, data = my_data))

# plot the data
p <-  ggplot(my_data, aes(x = x, y = y,
                          colour = abs(my_lm$residual))
) +
  geom_point() +
  scale_colour_gradient(low = "black", high = "red") +
  theme(legend.position = "none") +
  scale_x_continuous(
    expression(alpha^2 * pi / beta * sqrt(Theta)))

# add the regression line
p <- p + geom_abline(
  intercept = my_lm$coefficients[1][1],
  slope = my_lm$coefficients[2][1],
  colour = "red")
# throw some math on the plot
p <- p + geom_text(aes(x = 60, y = 0,
                       label = "sqrt(alpha) * 2* pi"), 
                   parse = TRUE, size = 6, 
                   colour = "blue")

p

###Saving the file in results
pdf("../results/MyLinReg.pdf")
print(p)
dev.off()
**********************************************************************

Testing plotLin.R...

Output (only first 500 characters): 


**********************************************************************
pdf 
  2 

**********************************************************************

Code ran without errors

Time consumed = 2.12840s

======================================================================
Inspecting script file basic_io.r...

File contents are:

**********************************************************************
#!usr/bin/env Rscript

# A simple script to illustrate R input-output.  
# Run line by line and check inputs outputs to understand what is happening  

MyData <- read.csv("../data/trees.csv", header = TRUE) # import with headers

write.csv(MyData, "../results/MyData.csv") #write it out as a new file

write.table(MyData[1,], file = "../results/MyData.csv",append=TRUE) # Append to it

write.csv(MyData, "../results/MyData.csv", row.names=TRUE) # write row names

write.table(MyData, "../results/MyData.csv", col.names=FALSE) # ignore column names
**********************************************************************

Testing basic_io.r...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

Warning message:
In write.table(MyData[1, ], file = "../results/MyData.csv", append = TRUE) :
  appending column names to file

======================================================================
Inspecting script file GPDD_Data.R...

File contents are:

**********************************************************************
#!usr/bin/env Rscript

#Cleaning the environment
rm(list = ls())

# Load the required libraries
library(maps)
library(ggplot2)

#Load data
load("../data/GPDDFiltered.RData")

#Creating a world map
map(database = "world")

# Plotting points on the map
points(x = gpdd$long, y = gpdd$lat, col = "red")

#Expected biases: projection bias; species included in this data set occur primarily in the Northern Hemisphere, which may lead to the false impression that it has higher species richness(map exclusion bias; it is hard to distinguish whether we are looking at multiple samples from one species or multiple species


**********************************************************************

Testing GPDD_Data.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 1.85873s

======================================================================
Inspecting script file Florida.R...

File contents are:

**********************************************************************
#!usr/bin/env Rscript

###libraries
library("ggpubr")
library("ggplot2")


###Cleaning the global environment

rm(list=ls())

###Loading the data from the data folder

load("../data/KeyWestAnnualMeanTemperature.RData")

ls()

###Checking the class and initial rows of the dataset 
class(ats)
head(ats)

###Plotting temperatures across years and saving the final plot

png(file="../data/plot1.png",
    width=1000, height=600)
ggscatter(ats, x = "Year", y = "Temp", 
          add = "reg.line", conf.int = TRUE, 
          cor.coef = TRUE, cor.method = "pearson",
          xlab = "Time (years)", ylab = "Temperatures")
dev.off()

###Checking the distribution of the temperature data
hist(ats$Temp)

###Calculating the initial correlation coefficient
result1 <- cor(ats$Year, ats$Temp, method = "pearson")

###Shuffling the temperatures 10k times and storing the values in a vector
cor_values <- rep(NA, 10000)

for (i in 1:10000) {
  sth <- sample(ats$Temp, 100, replace = FALSE)
  result <- cor(sth, ats$Year)
  cor_values[i]<- result
}

###Saving the pots in the results folder
png(file="../data/histogram1.png", width=1000, height=600)


###Printing a histogram of generated correlation coefficients with the initial value of the correlation coefficient plotted as a red line
histogram <- hist(cor_values, breaks = 100)
plot(histogram, xlim=c(-1,1), xlab = "Generated correlation coefficients", ylab = "Frequency", main ="Distribution of random correlation coefficients")
abline(v = result1, col="red")

dev.off()


###Calculating what fraction of the random correlation coefficients were greater than the observed one
fraction <- (length(cor_values[cor_values > result1]))/length(cor_values)
print(paste("The fraction is:", fraction))



**********************************************************************

Testing Florida.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

Error in library("ggpubr") : there is no package called ‘ggpubr’
Execution halted

======================================================================
Inspecting script file next.R...

File contents are:

**********************************************************************
#!usr/bin/env Rscript

###Practicing next statement

for (i in 1:10) {
  if ((i %% 2) == 0) # check if the number is odd
    next # pass to next iteration of loop 
  print(i)
}
**********************************************************************

Testing next.R...

Output (only first 500 characters): 


**********************************************************************
[1] 1
[1] 3
[1] 5
[1] 7
[1] 9

**********************************************************************

Code ran without errors

Time consumed = 0.45737s

======================================================================
Inspecting script file sample.R...

File contents are:

**********************************************************************
#!usr/bin/env Rscript

###Generating a random population and performing operations on it

######### Functions ##########

## A function to take a sample of size n from a population "popn" and return its mean
myexperiment <- function(popn,n) {
    pop_sample <- sample(popn, n, replace = FALSE)
    return(mean(pop_sample))
}

## Calculate means using a FOR loop on a vector without preallocation:
loopy_sample1 <- function(popn, n, num) {
    result1 <- vector() #Initialize empty vector of size 1 
    for(i in 1:num) {
        result1 <- c(result1, myexperiment(popn, n))
    }
    return(result1)
}

## To run "num" iterations of the experiment using a FOR loop on a vector with preallocation:
loopy_sample2 <- function(popn, n, num) {
    result2 <- vector(,num) #Preallocate expected size
    for(i in 1:num) {
        result2[i] <- myexperiment(popn, n)
    }
    return(result2)
}

## To run "num" iterations of the experiment using a FOR loop on a list with preallocation:
loopy_sample3 <- function(popn, n, num) {
    result3 <- vector("list", num) #Preallocate expected size
    for(i in 1:num) {
        result3[[i]] <- myexperiment(popn, n)
    }
    return(result3)
}


## To run "num" iterations of the experiment using vectorization with lapply:
lapply_sample <- function(popn, n, num) {
    result4 <- lapply(1:num, function(i) myexperiment(popn, n))
    return(result4)
}

## To run "num" iterations of the experiment using vectorization with sapply:
sapply_sample <- function(popn, n, num) {
    result5 <- sapply(1:num, function(i) myexperiment(popn, n))
    return(result5)
}

###Generating "random" numbers
set.seed(12345)
popn <- rnorm(10000) # Generate the population
hist(popn)

###Comapring times needed to run a given command

n <- 100 # sample size for each experiment
num <- 10000 # Number of times to rerun the experiment

print("Using loops without preallocation on a vector took:" )
print(system.time(loopy_sample1(popn, n, num)))

print("Using loops with preallocation on a vector took:" )
print(system.time(loopy_sample2(popn, n, num)))

print("Using loops with preallocation on a list took:" )
print(system.time(loopy_sample3(popn, n, num)))

print("Using the vectorized sapply function (on a list) took:" )
print(system.time(sapply_sample(popn, n, num)))

print("Using the vectorized lapply function (on a list) took:" )
print(system.time(lapply_sample(popn, n, num)))
**********************************************************************

Testing sample.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Using loops without preallocation on a vector took:"
   user  system elapsed 
  0.628   0.040   0.669 
[1] "Using loops with preallocation on a vector took:"
   user  system elapsed 
  0.367   0.000   0.368 
[1] "Using loops with preallocation on a list took:"
   user  system elapsed 
  0.371   0.000   0.371 
[1] "Using the vectorized sapply function (on a list) took:"
   user  system elapsed 
  0.502   0.000   0.503 
[1] "Using the vectorized lapply function (on a list) took:"
   user  syst
**********************************************************************

Code ran without errors

Time consumed = 2.96033s

======================================================================
Inspecting script file R_conditionals.R...

File contents are:

**********************************************************************
#!usr/bin/env Rscript

# Checks if an integer is even
is.even <- function(n = 2) {
    if (n %% 2 == 0) {
        return(paste(n, "is even!"))
    } else {
        return(paste(n, "is odd!"))
    }
}

print(is.even(6))
is.even()

# Checks if a number is a power of 2
is.power2 <- function(n = 2) {
  if (log2(n) %% 1==0) {
    return(paste(n, 'is a power of 2!'))
  } else {
  return(paste(n,'is not a power of 2!'))
    }
}

print(is.power2(4))

#Check if a number is prime
is.prime <- function(n) {
    if (n==0) {
        return(paste(n, "is a zero!"))
    } else if (n==1) {
        return(paste(n,"is just a unit"))
    }

    ints <- 2:(n-1)

    if (all(n%%ints!=0)) {
        return(paste(n,"is a prime!"))
    } else {
        return(paste(n, "is a composite!"))
    }
}

print(is.prime(3))

**********************************************************************

Testing R_conditionals.R...

Output (only first 500 characters): 


**********************************************************************
[1] "6 is even!"
[1] "2 is even!"
[1] "4 is a power of 2!"
[1] "3 is a prime!"

**********************************************************************

Code ran without errors

Time consumed = 0.46935s

======================================================================
======================================================================
Finished running scripts

Ran into 8 errors

======================================================================
======================================================================

FINISHED WEEKLY ASSESSMENT

Current Points for the Week = 100

NOTE THAT THESE ARE POINTS, NOT MARKS FOR THE WEEK!